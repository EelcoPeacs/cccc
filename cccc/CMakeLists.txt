

# Flags for ANTLR:
# -CC       = generate C++ output
# -k 2      = use at least 2 tokens of lookahead
# -gd       = generate rule tracing code (calls to tracein() and traceout())
# -ge       = generate token classes to represent the initial set for
#             each rule (called error sets, because their main use is
#             in simplifying error reporting when a rule fails).
# -rl 5000  = a limit on the size of the internal analysis network
#             used by the parser generator
# -w1       = basic error reporting
# The -gl flag is an option.  This causes ANTLR to emit #line directives
# which allow the compiler to generate line numbers relating to
# positions in the .g file instead of the generated cpp files.
# These can be useful to an IDE (jumping to error lines, e.g. in
# emacs), or in the debugger.
# At one time this option was broken to the extent that the code emitted
# was actually illegal under some circumstances, but it is better now.
# The problem is that there are still a lot of lines in the generated
# source which do not correspond with lines in the .g file.  On balance,
# if I am debugging it is better to leave -gl off, while for onward
# development it is better to turn it on and enable the IDE features.
set(AFLAGS -CC -k 2 -gd -ge -rl 5000 -w1 -e3)

# Flags for DLG
set(DFLAGS -C2 -CC)


if (CCCC_SUPPORT_CPP)
    ## list of files generated by the PCCTS utilities
    #set(CCCC_SPAWN_SOURCES_OUT
    #    ${CMAKE_CURRENT_BINARY_DIR}/cccc.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/CParser.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/CParser.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/Ctokens.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/CLexer.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/CLexer.h
    #)
    set(CPP_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/cccc.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CParser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CParser.h
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/Ctokens.h
    )
    set(CPP_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CLexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CLexer.h
    )
endif(CCCC_SUPPORT_CPP)


if (CCCC_SUPPORT_JAVA)
    #set(JAVA_SPAWN_SOURCES_OUT
    #    ${CMAKE_CURRENT_BINARY_DIR}/java.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/JParser.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/JParser.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/Jtokens.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/JLexer.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/JLexer.h
    #)
    set(JAVA_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/java.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JParser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JParser.h
        ${CMAKE_BINARY_DIR}/pccts_out/java/Jtokens.h
    )
    set(JAVA_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/java/JLexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JLexer.h
    )
endif (CCCC_SUPPORT_JAVA)

if (CCCC_SUPPORT_ADA)
    #set(ADA_SPAWN_SOURCES_OUT
    #    ${CMAKE_CURRENT_BINARY_DIR}/ada.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/AdaPrser.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/AdaPrser.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/Atokens.h
    #    ${CMAKE_CURRENT_BINARY_DIR}/ALexer.cpp
    #    ${CMAKE_CURRENT_BINARY_DIR}/ALexer.h
    #)
    set(ADA_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/ada.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/AdaPrser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/AdaPrser.h
        ${CMAKE_BINARY_DIR}/pccts_out/ada/Atokens.h
    )
    set(ADA_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/ada/ALexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/ALexer.h
    )
endif (CCCC_SUPPORT_ADA)

### the source files of the project itself
#set(USR_G
#    cccc.g
#    java.g
#    ada.g
#)


#USR_C = ccccmain.cc cccc_tok.cc cccc_met.cc cccc_utl.cc \
#                cccc_db.cc cccc_rec.cc cccc_ext.cc cccc_prj.cc cccc_mod.cc \
#                cccc_mem.cc cccc_use.cc cccc_htm.cc cccc_xml.cc cccc_tbl.cc \
#                cccc_tpl.cc cccc_new.cc cccc_itm.cc cccc_opt.cc

#USR_H = cccc.h cccc_tok.h cccc_met.h cccc_utl.h \
#                cccc_db.h cccc_htm.h cccc_tbl.h cccc_itm.h \
#                cccc_opt.h

### documentation
##USR_DOC =       README.md cccc_ug.htm

### the final executable is linked from 3 groups of object files:

## object files compiled from PCCTS support code which does not change
#PCCTS_OBJ = \
#    AParser.$(OBJEXT) \
#        DLexerBase.$(OBJEXT) \
#        ATokenBuffer.$(OBJEXT)

## object files compiled from C++ files generated by anltr and dlg
## They are now separated so that each language can be included or
## excluded by using make variables defined above.
#CCCC_SPAWN_OBJ=cccc.$(OBJEXT) CLexer.$(OBJEXT) CParser.$(OBJEXT)
#CC_LANG_DEFINE=-DCC_INCLUDED

#JAVA_SPAWN_OBJ=java.$(OBJEXT) JLexer.$(OBJEXT) JParser.$(OBJEXT)
#JAVA_LANG_DEFINE=-DJAVA_INCLUDED

##ADA_SPAWN_OBJ=ada.$(OBJEXT) ALexer.$(OBJEXT) AdaPrser.$(OBJEXT)
##ADA_LANG_DEFINE=-DADA_INCLUDED

#SPAWN_OBJ = $(CCCC_SPAWN_OBJ) $(JAVA_SPAWN_OBJ) $(ADA_SPAWN_OBJ)
#LANG_DEFINES = $(CC_LANG_DEFINE) $(JAVA_LANG_DEFINE) $(ADA_LANG_DEFINE)

## object files compiled from .cc files which are part of the cccc source
#USR_OBJ = \
#        ccccmain.$(OBJEXT) cccc_utl.$(OBJEXT) cccc_opt.$(OBJEXT) \
#        cccc_db.$(OBJEXT)  cccc_rec.$(OBJEXT) cccc_ext.$(OBJEXT) \
#        cccc_prj.$(OBJEXT) cccc_mod.$(OBJEXT) cccc_mem.$(OBJEXT) \
#        cccc_use.$(OBJEXT) cccc_met.$(OBJEXT) cccc_htm.$(OBJEXT) cccc_xml.$(OBJEXT) \
#        cccc_tok.$(OBJEXT) cccc_tbl.$(OBJEXT) \
#        cccc_tpl.$(OBJEXT) cccc_new.$(OBJEXT) cccc_itm.$(OBJEXT) \


#ALL_OBJ = $(SPAWN_OBJ) $(USR_OBJ) $(PCCTS_OBJ)



#all: $(CCCC_EXE)


#$(CCCC_EXE): $(USR_G) $(ANLTR_SPAWN) $(DLG_SPAWN) $(USR_H) $(USR_C) $(ALL_OBJ)
#        $(CCC) $(ALL_OBJ) $(LD_OPTS)  $(LD_EXTRA_LIBS) $(LD_OFLAG)$(CCCC_EXE)

#.SUFFIXES: .cc .$(OBJEXT) .cpp .cxx .g .g_info

### ANTLR can give us some very useful documentation including a
### cross reference of the rules and a list of first token sets
### for each rule

#.g.g_info:
#        $(ANTLR) $(AFLAGS) -gc -gx -pa $< > $*.1st
#        $(ANTLR) $(AFLAGS) -gc -gx -cr $< > $*.xrf

#ccccmain.$(OBJEXT) : ccccmain.cc
#        $(CCC) $(CCC_OPTS) $(LANG_DEFINES) ccccmain.cc


#.cc.$(OBJEXT):
#        $(CCC) $(CCC_OPTS) $< $(C_OFLAG)$*.$(OBJEXT)

#.cpp.$(OBJEXT):
#        $(CCC) $(CCC_OPTS) $< $(C_OFLAG)$*.$(OBJEXT)

#.cxx.$(OBJEXT):
#        $(CCC) -c $(CCC_OPTS) $< $(C_OFLAG)$*.$(OBJEXT)

## Different compilers handle the source file being in a
## different directory in different ways.  The easiest way
## to cover this is to add explicit rules for the three
## PCCTS support files which give rise to linkable object
## files.
#AParser.$(OBJEXT): $(PCCTS_H)$(PATHSEP)AParser.cpp
#        $(CCC) $(CCC_OPTS) $(PCCTS_H)$(PATHSEP)AParser.cpp $(C_OFLAG)$*.$(OBJEXT)

#DLexerBase.$(OBJEXT): $(PCCTS_H)$(PATHSEP)DLexerBase.cpp
#        $(CCC) $(CCC_OPTS) $(PCCTS_H)$(PATHSEP)DLexerBase.cpp $(C_OFLAG)$*.$(OBJEXT)

#ATokenBuffer.$(OBJEXT): $(PCCTS_H)$(PATHSEP)ATokenBuffer.cpp
#        $(CCC) $(CCC_OPTS) $(PCCTS_H)$(PATHSEP)ATokenBuffer.cpp $(C_OFLAG)$*.$(OBJEXT)



#$(CCCC_SPAWN) : cccc.g
#        $(ANTLR) $(AFLAGS) -ft Ctokens.h cccc.g
#        $(DLG) $(DFLAGS) -cl CLexer parser.dlg

#$(JAVA_SPAWN) : java.g
#        $(ANTLR) $(AFLAGS) -ft Jtokens.h java.g
#        $(DLG) $(DFLAGS) -cl JLexer parser.dlg

### -ci argument to DLG is because unlike C\C++\Java, Ada is defined as being
### case insensitive
### NB CCCC does not map case: if the code processed is not consistent in
### capitalisation of the name of a package, the reports will treat it as
### two different packages
#$(ADA_SPAWN) : ada.g
#        $(ANTLR) $(AFLAGS) -ft Atokens.h ada.g
#        $(DLG) $(DFLAGS) -ci -cl ALexer parser.dlg






##if(EXISTS pccts/antlr.exe)
##    if(EXISTS pccts/antlr.exe)
#        add_custom_command(OUTPUT ${CCCC_SPAWN_SOURCES_OUT}
#            COMMAND pccts/antlr.exe ${AFLAGS} -ft Ctokens.h ${PROJECT_SOURCE_DIR}/cccc.g
#            COMMAND $(DLG) $(DFLAGS) -cl CLexer parser.dlg
#            DEPENDS antlr dlg
#            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
##            WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#            COMMENT Building C++ parser)
##        SET(PCRE2_SOURCES ${PCRE2_SOURCES} ${PROJECT_SOURCE_DIR}/pcre2.o)

#        add_custom_command(OUTPUT ${JAVA_SPAWN_SOURCES_OUT}
#            COMMAND pccts/antlr.exe ${AFLAGS} -ft Jtokens.h ${PROJECT_SOURCE_DIR}/java.g
#            COMMAND $(DLG) $(DFLAGS) -cl JLexer parser.dlg
#            DEPENDS antlr dlg
#            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
##            WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#            COMMENT Building Java parser)
##        SET(PCRE2_SOURCES ${PCRE2_SOURCES} ${PROJECT_SOURCE_DIR}/pcre2.o)

#        ## -ci argument to DLG is because unlike C\C++\Java, Ada is defined as being
#        ## case insensitive
#        ## NB CCCC does not map case: if the code processed is not consistent in
#        ## capitalisation of the name of a package, the reports will treat it as
#        ## two different packages
#        add_custom_command(OUTPUT ${ADA_SPAWN_SOURCES_OUT}
#            COMMAND pccts/antlr.exe ${AFLAGS} -ft Atokens.h ${PROJECT_SOURCE_DIR}/ada.g
#            COMMAND $(DLG) $(DFLAGS) -ci -cl ALexer parser.dlg
#            DEPENDS antlr dlg
#            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
##            WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#            COMMENT Building Ada parser)
##        SET(PCRE2_SOURCES ${PCRE2_SOURCES} ${PROJECT_SOURCE_DIR}/pcre2.o)
##    endif(EXISTS pccts/antlr.exe)
##endif(EXISTS pccts/antlr.exe)


# Get all source files
#file(GLOB CCCC_SRCS "*.cc")
#file(GLOB PUBLIC_HEADERS "*.h")


set(CCCC_SRCS
    ccccmain.cc
    cccc_tok.cc
    cccc_met.cc
    cccc_utl.cc
    cccc_db.cc
    cccc_rec.cc
    cccc_ext.cc
    cccc_prj.cc
    cccc_mod.cc
    cccc_mem.cc
    cccc_use.cc
    cccc_htm.cc
    cccc_xml.cc
    cccc_tbl.cc
    cccc_tpl.cc
    cccc_new.cc
    cccc_itm.cc
    cccc_opt.cc
    ../pccts/h/AParser.cpp
    ../pccts/h/DLexerBase.cpp
    ../pccts/h/ATokenBuffer.cpp
)


if (CMAKE_DEBUG_POSTFIX STREQUAL "")
    set(ANTLR_EXE ${CMAKE_BINARY_DIR}/bin/antlr.exe)
    set(DLG_EXE ${CMAKE_BINARY_DIR}/bin/dlg.exe)
else()
    set(ANTLR_EXE ${CMAKE_BINARY_DIR}/bin/antlr${CMAKE_DEBUG_POSTFIX}.exe)
    set(DLG_EXE ${CMAKE_BINARY_DIR}/bin/dlg${CMAKE_DEBUG_POSTFIX}.exe)
endif(CMAKE_DEBUG_POSTFIX STREQUAL "")


# Create a folder for the pccts tools to create their output and copy the source files to it
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out)

if (CCCC_SUPPORT_CPP)
    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/cccc.g ${CMAKE_BINARY_DIR}/pccts_out/cccc.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(cpp_antlr
        COMMAND ${ANTLR_EXE} ${AFLAGS} -ft Ctokens.h ${CMAKE_BINARY_DIR}/pccts_out/cccc.g
        DEPENDS antlr
        BYPRODUCTS ${CPP_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp
        COMMENT Building C++ parser step: antlr)

    # Step 2
    add_custom_target(cpp_parser
        COMMAND ${DLG_EXE} ${DFLAGS} -cl CLexer parser.dlg
        DEPENDS dlg cpp_antlr
        BYPRODUCTS ${CPP_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp
        COMMENT Building C++ parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${CPP_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${CPP_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_CPP)

if (CCCC_SUPPORT_JAVA)
    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/java.g ${CMAKE_BINARY_DIR}/pccts_out/java.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(java_antlr
        COMMAND ${ANTLR_EXE} ${AFLAGS} -ft Jtokens.h ${CMAKE_BINARY_DIR}/pccts_out/java.g
        DEPENDS antlr
        BYPRODUCTS ${JAVA_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java
        COMMENT Building Java parser step: antlr)

    # Step 2
    add_custom_target(java_parser
        COMMAND ${DLG_EXE} ${DFLAGS} -cl JLexer parser.dlg
        DEPENDS dlg java_antlr
        BYPRODUCTS ${JAVA_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java
        COMMENT Building Java parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${JAVA_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${JAVA_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_JAVA)

if (CCCC_SUPPORT_ADA)
    ## -ci argument to DLG is because unlike C\C++\Java, Ada is defined as being
    ## case insensitive
    ## NB CCCC does not map case: if the code processed is not consistent in
    ## capitalisation of the name of a package, the reports will treat it as
    ## two different packages

    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/ada.g ${CMAKE_BINARY_DIR}/pccts_out/ada.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(ada_antlr
        COMMAND ${ANTLR_EXE} ${AFLAGS} -ft Atokens.h ${CMAKE_BINARY_DIR}/pccts_out/ada.g
        DEPENDS antlr
        BYPRODUCTS ${ADA_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada
        COMMENT Building Ada parser step: antlr)

    # Step 2
    add_custom_target(ada_parser
        COMMAND ${DLG_EXE} ${DFLAGS} -ci -cl ALexer parser.dlg
        DEPENDS dlg ada_antlr
        BYPRODUCTS ${ADA_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada
        COMMENT Building Ada parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${ADA_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${ADA_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_ADA)

add_executable(cccc ${CCCC_SRCS})
set_target_properties(cccc PROPERTIES LINKER_LANGUAGE C)
set_target_properties (cccc PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})
set_target_properties(cccc PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")

include_directories(cccc . ../pccts/h ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/pccts_out)

add_dependencies(cccc antlr dlg)
if (CCCC_SUPPORT_CPP)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/cpp)
    target_compile_definitions(cccc PRIVATE CC_INCLUDED)
    add_dependencies(cccc cpp_parser)
endif ()
if (CCCC_SUPPORT_JAVA)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/java)
    target_compile_definitions(cccc PRIVATE JAVA_INCLUDED)
    add_dependencies(cccc java_parser)
endif ()
if (CCCC_SUPPORT_ADA)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/ada)
    target_compile_definitions(cccc PRIVATE ADA_INCLUDED)
    add_dependencies(cccc ada_parser)
endif ()


#install(TARGETS cccc CONFIGURATIONS Debug DESTINATION ../bin/debug)
#install(TARGETS cccc CONFIGURATIONS Release DESTINATION ../bin/release)
