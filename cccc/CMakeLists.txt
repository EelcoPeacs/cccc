

# Flags for ANTLR:
# -CC       = generate C++ output
# -k 2      = use at least 2 tokens of lookahead
# -gd       = generate rule tracing code (calls to tracein() and traceout())
# -ge       = generate token classes to represent the initial set for
#             each rule (called error sets, because their main use is
#             in simplifying error reporting when a rule fails).
# -rl 5000  = a limit on the size of the internal analysis network
#             used by the parser generator
# -w1       = basic error reporting
# The -gl flag is an option.  This causes ANTLR to emit #line directives
# which allow the compiler to generate line numbers relating to
# positions in the .g file instead of the generated cpp files.
# These can be useful to an IDE (jumping to error lines, e.g. in
# emacs), or in the debugger.
# At one time this option was broken to the extent that the code emitted
# was actually illegal under some circumstances, but it is better now.
# The problem is that there are still a lot of lines in the generated
# source which do not correspond with lines in the .g file.  On balance,
# if I am debugging it is better to leave -gl off, while for onward
# development it is better to turn it on and enable the IDE features.
set(AFLAGS -CC -k 2 -gd -ge -rl 5000 -w1 -e3)

# Flags for DLG
set(DFLAGS -C2 -CC)

if(WIN32)
    add_compile_definitions( CCCC_CONF_W32VC )
endif(WIN32)


## list of files generated by the PCCTS utilities

if (CCCC_SUPPORT_CPP)
    set(CPP_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/cccc.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CParser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CParser.h
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/Ctokens.h
    )
    set(CPP_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CLexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/cpp/CLexer.h
    )
endif(CCCC_SUPPORT_CPP)

if (CCCC_SUPPORT_JAVA)
    set(JAVA_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/java.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JParser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JParser.h
        ${CMAKE_BINARY_DIR}/pccts_out/java/Jtokens.h
    )
    set(JAVA_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/java/JLexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/java/JLexer.h
    )
endif (CCCC_SUPPORT_JAVA)

if (CCCC_SUPPORT_ADA)
    set(ADA_ANTLR_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/ada.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/AdaPrser.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/AdaPrser.h
        ${CMAKE_BINARY_DIR}/pccts_out/ada/Atokens.h
    )
    set(ADA_DLG_SOURCES_OUT
        ${CMAKE_BINARY_DIR}/pccts_out/ada/ALexer.cpp
        ${CMAKE_BINARY_DIR}/pccts_out/ada/ALexer.h
    )
endif (CCCC_SUPPORT_ADA)


set(CCCC_SRCS
    ccccmain.cc
    cccc_tok.cc
    cccc_met.cc
    cccc_utl.cc
    cccc_db.cc
    cccc_rec.cc
    cccc_ext.cc
    cccc_prj.cc
    cccc_mod.cc
    cccc_mem.cc
    cccc_use.cc
    cccc_htm.cc
    cccc_xml.cc
    cccc_tbl.cc
    cccc_tpl.cc
    cccc_new.cc
    cccc_itm.cc
    cccc_opt.cc
    ../pccts/h/AParser.cpp
    ../pccts/h/DLexerBase.cpp
    ../pccts/h/ATokenBuffer.cpp
)


# Create a folder for the pccts tools to create their output and copy the source files to it
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out)

if (CCCC_SUPPORT_CPP)
    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/cccc.g ${CMAKE_BINARY_DIR}/pccts_out/cccc.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(cpp_antlr
        COMMAND $<TARGET_FILE:antlr> ${AFLAGS} -ft Ctokens.h ${CMAKE_BINARY_DIR}/pccts_out/cccc.g
        DEPENDS antlr
        BYPRODUCTS ${CPP_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp
        COMMENT Building C++ parser step: antlr)
		
    # Step 2
    add_custom_target(cpp_parser
        COMMAND $<TARGET_FILE:dlg> ${DFLAGS} -cl CLexer parser.dlg
        DEPENDS dlg cpp_antlr
        BYPRODUCTS ${CPP_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/cpp
        COMMENT Building C++ parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${CPP_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${CPP_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_CPP)

if (CCCC_SUPPORT_JAVA)
    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/java.g ${CMAKE_BINARY_DIR}/pccts_out/java.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(java_antlr
        COMMAND $<TARGET_FILE:antlr> ${AFLAGS} -ft Jtokens.h ${CMAKE_BINARY_DIR}/pccts_out/java.g
        DEPENDS antlr
        BYPRODUCTS ${JAVA_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java
        COMMENT Building Java parser step: antlr)
		
    # Step 2
    add_custom_target(java_parser
        COMMAND $<TARGET_FILE:dlg> ${DFLAGS} -cl JLexer parser.dlg
        DEPENDS dlg java_antlr
        BYPRODUCTS ${JAVA_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/java
        COMMENT Building Java parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${JAVA_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${JAVA_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_JAVA)

if (CCCC_SUPPORT_ADA)
    ## -ci argument to DLG is because unlike C\C++\Java, Ada is defined as being
    ## case insensitive
    ## NB CCCC does not map case: if the code processed is not consistent in
    ## capitalisation of the name of a package, the reports will treat it as
    ## two different packages

    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada)
    file(COPY_FILE ${CMAKE_CURRENT_SOURCE_DIR}/ada.g ${CMAKE_BINARY_DIR}/pccts_out/ada.g ONLY_IF_DIFFERENT)

    # Step 1
    add_custom_target(ada_antlr
        COMMAND $<TARGET_FILE:antlr> ${AFLAGS} -ft Atokens.h ${CMAKE_BINARY_DIR}/pccts_out/ada.g
        DEPENDS antlr
        BYPRODUCTS ${ADA_ANTLR_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada
        COMMENT Building Ada parser step: antlr)

    # Step 2
    add_custom_target(ada_parser
        COMMAND $<TARGET_FILE:dlg> ${DFLAGS} -ci -cl ALexer parser.dlg
        DEPENDS dlg ada_antlr
        BYPRODUCTS ${ADA_DLG_SOURCES_OUT}
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/pccts_out/ada
        COMMENT Building Ada parser step: dlg)

    set(CCCC_SRCS ${CCCC_SRCS} ${ADA_ANTLR_SOURCES_OUT})
    set(CCCC_SRCS ${CCCC_SRCS} ${ADA_DLG_SOURCES_OUT})
endif (CCCC_SUPPORT_ADA)

add_executable(cccc ${CCCC_SRCS})
set_target_properties(cccc PROPERTIES LINKER_LANGUAGE C)
set_target_properties (cccc PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})
set_target_properties(cccc PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")

include_directories(cccc . ../pccts/h ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/pccts_out)

add_dependencies(cccc antlr dlg)
if (CCCC_SUPPORT_CPP)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/cpp)
    target_compile_definitions(cccc PRIVATE CC_INCLUDED)
    add_dependencies(cccc cpp_parser)
endif ()
if (CCCC_SUPPORT_JAVA)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/java)
    target_compile_definitions(cccc PRIVATE JAVA_INCLUDED)
    add_dependencies(cccc java_parser)
endif ()
if (CCCC_SUPPORT_ADA)
    include_directories(cccc ${CMAKE_BINARY_DIR}/pccts_out/ada)
    target_compile_definitions(cccc PRIVATE ADA_INCLUDED)
    add_dependencies(cccc ada_parser)
endif ()
